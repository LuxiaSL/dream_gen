# Dream Window Configuration
# Edit this file to customize behavior

system:
  # ComfyUI server (will be on Windows machine)
  comfyui_url: "http://127.0.0.1:8188"
  # Note: ComfyUI output directory is not needed since we fetch images via API
  # The get_image_data() method retrieves images directly without file system access
  
  # Paths (relative to project root by default)
  output_dir: "./output"
  cache_dir: "./cache"
  seed_dir: "./seeds"
  log_dir: "./logs"
  
  # GPU configuration (Windows only)
  gpu_id: 0 # GPU #2 (0-indexed) for dedicated generation
  
  # Logging
  log_level: "INFO"  # DEBUG, INFO, WARNING, ERROR

generation:
  # === PARALLELIZATION FEATURE FLAG ===
  # Enable async orchestrator for 2x+ FPS improvement
  # When true: Uses new AsyncGenerationOrchestrator (KeyframeWorker + InterpolationWorker + CacheWorker)
  # When false: Uses legacy GenerationCoordinator (rollback safety)
  # Default: false (enable after testing)
  use_async_orchestrator: true
  
  # Model selection
  model: "sd15"  # "sd15", "flux.1-schnell", or "sd21-unclip"
  resolution: [512, 256]    # Width x Height
  mode: "hybrid"            # "interpolate", "img2img", or "hybrid" (recommended)
  
  # Flux.1 parameters (when model: "flux.1-schnell")
  flux:
    steps: 4                # Flux schnell is optimized for 4 steps
    cfg_scale: 1.0          # Flux uses low CFG (guidance scale)
    sampler: "euler"
    scheduler: "simple"
  
  # SD 1.5 / 2.1 parameters (when model: "sd15" or "sd21-unclip")
  sd:
    steps: 10               # SD typically uses 20-30 steps, but 10 is fine for drifting and faster
    cfg_scale: 6.0          
    sampler: "euler"      # euler_a works well for SD
    scheduler: "karras"
  
  # Hybrid mode configuration (RECOMMENDED for best speed/quality balance)
  hybrid:
    # === FRAME GENERATION ARCHITECTURE ===
    # The system works in a loop:
    # 1. Generate KEYFRAME (full SD diffusion, ~2.1s)
    # 2. Create N INTERPOLATION FRAMES between keyframes (VAE latent lerp)
    # 3. Display all frames at target FPS
    # 4. Repeat with next keyframe
    
    # Number of interpolated frames between each keyframe
    # More frames = smoother animation but longer wait between keyframes
    # Example: 10 frames @ 10fps = 1 second of smooth playback per keyframe
    interpolation_frames: 10
    
    # Target playback framerate (fps) for interpolated frames
    # This controls how fast interpolation frames are displayed
    # TESTED PERFORMANCE:
    # - Full res (512x256): ~4 FPS max
    # - Half res (256x128): ~15 FPS max
    # Set this based on your interpolation_resolution_divisor and GPU speed
    target_interpolation_fps: 3.5
    
    # Keyframe generation strength (0.0-1.0)
    # Higher = more variation between keyframes, lower = smoother evolution
    keyframe_denoise: 0.2
    
    # PERFORMANCE OPTIMIZATION: Lower-resolution interpolation
    # Interpolate at lower resolution, then upscale for massive speedup
    # TESTED CONFIGURATIONS (2025-11-09):
    # 1 = full resolution (512x256) - highest quality, ~4 FPS
    # 1.5 = 3/4 resolution (384x192) - ~8 FPS
    # 2 = half resolution (256x128) - ~15 FPS
    interpolation_resolution_divisor: 1
    
    # Upscaling method for lower-res interpolation
    # "bilinear" - Fast, good quality (RECOMMENDED)
    # "bicubic" - Slightly better quality, slightly slower
    # "nearest" - Fastest, pixelated (not recommended)
    interpolation_upscale_method: "bilinear"
    
    # Downsampling method before VAE encoding (for lower-res interpolation)
    # "bilinear" - Fast, good quality (RECOMMENDED)
    # "bicubic" - Middle ground, slight quality improvement
    # "lanczos" - Best quality, slightly slower (~10ms overhead)
    interpolation_downsample_method: "bicubic"
  
  # img2img parameters (for feedback loop mode)
  img2img:
    denoise: 0.3               # Lower = slower drift, higher = more variation
    # 0.3 = very slow evolution (preserves structure)
    # 0.4 = balanced (recommended)
    # 0.5 = faster changes
    # 0.6+ = rapid mutation (might break aesthetic)
  
  # Cache system
  cache:
    max_size: 50                    # Number of images to cache (LRU eviction)
    
    # === SIMILARITY METHOD ===
    similarity_method: "dual_metric"   # ColorHist + pHash-8 dual-metric system
    
    # === CACHE POPULATION (Component 2) ===
    population_mode: "selective"       # "all" or "selective"
    cache_interpolations: true         # Cache interpolation midpoints
    cache_diversity_logic: "all"       # "all" = AND (both metrics must be diverse)
                                       # "any" = OR (either metric can be diverse)
                                       # Recommend: "all" for high-quality diverse cache
    
    # === DUAL-METRIC SETTINGS (ColorHist + pHash-8) ===
    # Color histogram configuration
    color_histogram:
      bins_per_channel: 32             # 32 bins × 3 channels (HSV) = 96-dim vector
      diversity_threshold: 1.92        # Cache if avg similarity < 1.92
                                       # TUNED 2025-11-12 v3: Tightened to reduce near-duplicates
                                       # Previous: 1.95 (30.2% acceptance)
                                       # Target: ~27% acceptance (conservative reduction)
                                       # Cuts into the 1.90-1.95 cluster where near-duplicates occur
      dissimilarity_range: [1.18, 2.05]  # "Related but different" zone (for injection)
                                       # Widened slightly to compensate for stricter caching
                                       # Maintains injection pool diversity
      convergence_threshold: 0.15      # Delta threshold for scaling injection
      force_cache_threshold: 0.30      # Delta threshold for forcing cache
    
    # Perceptual hash configuration
    phash:
      hash_size: 8                     # 8×8 DCT hash (64 bits)
      diversity_threshold: 0.80        # Cache if avg similarity < 0.80
                                       # TUNED 2025-11-12 v3: Tightened for better structural uniqueness
                                       # Previous: 0.82 (30.2% acceptance)
                                       # Target: ~27% acceptance (conservative reduction)
                                       # Raises bar for structural diversity
      dissimilarity_range: [0.68, 0.92]  # "Related but different" zone (for injection)
                                       # Widened slightly to compensate for stricter caching
                                       # Maintains injection pool diversity
      convergence_threshold: 0.08      # Delta threshold for scaling injection
      force_cache_threshold: 0.15      # Delta threshold for forcing cache
    
    # Detection logic (for collapse detection and injection)
    injection_logic: "any"             # "any" = OR logic (either metric triggers collapse/injection)
                                       # "all" = AND logic (both must trigger)
                                       # Recommend: "any" for sensitive collapse detection
                                       
    # NOTE: Different logic for different purposes:
    # - cache_diversity_logic: "all" (AND) → ensures BOTH color & structure diverse → high-quality cache
    # - injection_logic: "any" (OR) → detects ANY type of collapse → sensitive watchdog
    
    # === INJECTION STRATEGY (Component 3) ===
    injection_mode: "dissimilar"       # "similar" or "dissimilar"
    injection_probability: 0.15        # Base injection probability (15%)
    blend_weight: 0.75                  # VAE blend: % cached frame (0.0-1.0)
                                       # Higher = more influence from cached frame
    
    # Anti-loop protection (prevents repeated injections)
    injection_cooldown: 2              # Minimum keyframes between cache injections
    seed_injection_cooldown: 2         # Minimum keyframes between seed injections
    embedding_history_reset: "partial" # "none", "partial", or "full" after injection
    embedding_history_keep_recent: 10   # If partial reset, keep this many recent frames
    
    # === MODE COLLAPSE DETECTION (Component 1) ===
    collapse_detection: true
    
    # Warmup period: disable ALL injections during initial aesthetic establishment
    # Recommendation: Set to at least 40 (collapse detection window size)
    # This lets img2img naturally drift and establishes baseline before interventions
    warmup_keyframes: 10               # No cache/seed injection until this many keyframes
    
    # Convergence detection mode: "absolute" or "percentage"
    # NOTE: With dual-metric system, thresholds are defined per-metric above
    #       (color_histogram.convergence_threshold, phash.convergence_threshold)
    convergence_mode: "absolute"       # "absolute" uses delta thresholds, "percentage" uses % increase
    
    # Logging for calibration
    log_convergence_stats: true        # Log delta values for tuning
    
    # === ADAPTIVE SEED INJECTION (Component 4) ===
    # Probability increases with cache injection count
    seed_injection_floor: 0.02         # Minimum probability (2%)
    seed_injection_max: 0.15           # Maximum probability (15%)
    seed_injection_ramp: 50            # Reach max after this many cache injections
    
    # Early seed injection boost (bootstrap phase)
    seed_injection_boost_threshold: 10  # Boost seed probability when cache < 10 frames
    seed_injection_boost_probability: 0.20  # 20% seed injection during bootstrap
    
    # Forced seed injection on frequent cache injections
    # If >30% of recent 20 keyframes used cache injection, force seed reset
    force_seed_injection_frequency: 0.30  # Force seed if >30% recent injections
    
    # Seed blending options
    blend_seed_injection: true         # Blend seeds with current frame
    seed_blend_weight: 0.85             # VAE blend: % seed (0.0-1.0)
    
    # === LOGGING & METRICS ===
    log_diversity_stats: true          # Log cache diversity metrics
    diversity_check_interval: 10       # Log every N keyframes
    
    # === PHASE 2: ADVANCED CACHE MONITORING (Future Enhancement) ===
    # These settings are designed for future use with AsyncGenerationOrchestrator
    # See: docs/ASYNC_CACHE_MONITORING_DESIGN.md for details
    # When enabled, provides continuous background monitoring and smart eviction
    advanced_monitoring:
      enabled: false                   # Enable Phase 2 monitoring (not yet implemented)
      eviction_strategy: "lru"         # "lru" or "redundancy" (Phase 2: smart eviction)
      acceptance_logic: "average"      # "average" or "max_similarity" (Phase 2: stricter logic)
      diversity_matrix_refresh: 50     # Recalculate diversity matrix every N keyframes
      # Phase 2 will add:
      # - Continuous O(N²) diversity matrix
      # - Redundancy-based eviction (remove duplicates first)
      # - Max-similarity acceptance (stricter than average)
      # - Cluster detection
      # - Adaptive threshold tuning

display:
  # === BUFFERED DISPLAY SYSTEM ===
  # New architecture: Fill buffer with frames before starting playback
  # This ensures smooth, uninterrupted visual experience
  
  # Buffer target in seconds (30s = "crumple zone" for smooth playback)
  # System will generate this many seconds worth of frames before displaying
  buffer_target_seconds: 30.0
  
  # Minimum buffer before starting playback (can be lower than target for faster startup)
  min_buffer_seconds: 10.0
  
  # NOTE: Display FPS is controlled by hybrid.target_interpolation_fps
  
  # Output management
  max_output_frames: 100          # Keep only last N frames in output dir (prevents unbounded growth)
  
prompts:
  # Theme pairs (positive + negative prompts)
  # Each theme can have its own tailored negative prompt for better control
  theme_pairs:
    - positive: "black, white, ethereal digital angel, dissolving into particles, flowing white lines, technical wireframe overlay, monochrome, sparse color accents, architectural diagrams, high contrast, abstract geometry"
      negative: "colors, red, blue, green, yellow, orange, purple, pink, brown, low quality, text, watermark, signature, jpeg artifacts, muddy colors, brown tones, warm colors"
    
    - positive: "abstract geometry, technical wireframe, architectural diagrams, flowing lines, blueprint aesthetic, monochrome with data corruption, cyberpunk overlay, grid patterns, high contrast"
      negative: "organic forms, curves, nature, soft edges, blur, low quality, text, watermark, signature, jpeg artifacts, low contrast, muddy colors"
    
    - positive: "cyberpunk angel, glitch art aesthetic, digital corruption, technical overlay, particle dissolution, monochrome with red and cyan accents, wireframe structure, abstract form, high contrast"
      negative: "smooth, clean, pristine, perfect, polished, blur, low quality, text, watermark, signature, jpeg artifacts, low contrast, natural lighting"
    
    - positive: "black, white, ethereal figure in data stream, technical readouts, flowing particles, architectural wireframe, monochrome with blue highlights, digital dissolution, abstract geometry, high contrast"
      negative: "solid forms, static, stable, grounded, physical, blur, low quality, text, watermark, signature, jpeg artifacts, low contrast, warm colors"
  
  # Prompt modifiers (optional enhancements)
  modifiers:
    enabled: true
    time_based: true              # Inject time-of-day variations
    system_based: false           # Future: CPU load affects prompt
  
  # Rotation strategy - KEYFRAME based (not interpolation frames!)
  # Prompts rotate when generating new keyframes, not during interpolation
  rotation_interval: 20           # Number of KEYFRAMES before switching base theme
                                  # Example: 20 keyframes = 20 theme cycles before rotation

# Game detection (auto-pause generation)
game_detection:
  enabled: true
  method: "process"               # "process", "gpu_load", or "fullscreen"
  check_interval: 5.0             # Seconds between checks
  
  # Known game executables (add your games here)
  known_games:
    - "eldenring.exe"
    - "cyberpunk2077.exe"
  
  gpu_threshold: 80               # GPU load % to trigger pause (if using gpu_load method)
  
performance:
  max_queue_size: 60              # Max frames in generation queue
  generation_timeout: 120          # Seconds before considering generation stuck (increased for Maxwell GPUs)
  enable_torch_compile: false     # PyTorch 2.0 optimization (experimental)
  async_file_operations: true     # Non-blocking file writes

# Daemon service (for Rainmeter auto-launch and process management)
daemon:
  enabled: true                   # Enable daemon mode (vs manual launch)
  
  # ComfyUI Backend Configuration
  # IMPORTANT: Customize these paths for your setup!
  comfyui:
    # Path to ComfyUI startup script (relative to project root or absolute)
    # The .bat file handles ComfyUI's own virtual environment
    # Windows: Use .bat file (recommended)
    # Linux/Mac: Use .sh file or python command
    startup_script: "diffusion/ComfyUI/run_nvidia_gpu_gpu1_fast.bat"
    
    # Alternative examples:
    # startup_script: "diffusion/ComfyUI/run_nvidia_gpu.bat"
    # startup_script: "uv run diffusion/ComfyUI/main.py --listen 127.0.0.1 --port 8188"
    
    # How long to wait for ComfyUI to become responsive (seconds)
    startup_timeout: 300
    
    # Health check: URL to verify ComfyUI is ready
    health_check_url: "http://127.0.0.1:8188/system_stats"
    health_check_interval: 2      # Seconds between checks during startup
  
  # DreamController Configuration
  controller:
    # Python executable for running the controller
    # Options:
    #   "auto" - Use current Python (same as daemon)
    #   ".venv/Scripts/python.exe" - Explicit venv path (Windows)
    #   ".venv/bin/python" - Explicit venv path (Linux/Mac)
    #   "C:/path/to/python.exe" - Absolute path
    python_executable: ".venv/Scripts/python.exe"
    
    # Script to run
    main_script: "backend/main.py"
    
  # Process Management
  auto_restart:
    comfyui: true                 # Auto-restart ComfyUI if it crashes
    controller: true              # Auto-restart dream_gen loop if it crashes
    max_restarts: 5               # Max restarts before giving up (per hour)
    restart_delay: 10             # Seconds to wait before restart attempt
    
  # Control Interface
  control_file: "output/daemon_control.txt"   # File for pause/resume/shutdown commands
  control_check_interval: 2       # Seconds between checking control file
  
  # Status & Monitoring
  pid_file: "output/daemon.pid"   # PID file for daemon process tracking
  status_update_interval: 5       # Seconds between daemon status updates
  
  # Graceful Shutdown
  shutdown:
    comfyui_grace_period: 30      # Seconds to wait for ComfyUI clean exit
    controller_grace_period: 10   # Seconds to wait for controller clean exit
    force_kill_after_timeout: true # Force kill if grace period expires
    
  # Logging
  log_file: "logs/daemon.log"     # Daemon-specific log file
  log_level: "INFO"               # DEBUG, INFO, WARNING, ERROR

