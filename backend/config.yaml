# Dream Window Configuration
# Edit this file to customize behavior

system:
  # ComfyUI server (will be on Windows machine)
  comfyui_url: "http://127.0.0.1:8188"
  # Note: ComfyUI output directory is not needed since we fetch images via API
  # The get_image_data() method retrieves images directly without file system access
  
  # Paths (relative to project root by default)
  output_dir: "./output"
  cache_dir: "./cache"
  seed_dir: "./seeds"
  log_dir: "./logs"
  
  # GPU configuration (Windows only)
  gpu_id: 1  # GPU #2 (0-indexed) for dedicated generation
  
  # Logging
  log_level: "INFO"  # DEBUG, INFO, WARNING, ERROR

generation:
  # Model selection
  model: "sd15"  # "sd15", "flux.1-schnell", or "sd21-unclip"
  resolution: [512, 256]    # Width x Height
  mode: "hybrid"            # "interpolate", "img2img", or "hybrid" (recommended)
  
  # Flux.1 parameters (when model: "flux.1-schnell")
  flux:
    steps: 4                # Flux schnell is optimized for 4 steps
    cfg_scale: 1.0          # Flux uses low CFG (guidance scale)
    sampler: "euler"
    scheduler: "simple"
  
  # SD 1.5 / 2.1 parameters (when model: "sd15" or "sd21-unclip")
  sd:
    steps: 10               # SD typically uses 20-30 steps, but 10 is fine for drifting and faster
    cfg_scale: 6.0          
    sampler: "euler"      # euler_a works well for SD
    scheduler: "karras"
  
  # Hybrid mode configuration (RECOMMENDED for best speed/quality balance)
  hybrid:
    # === FRAME GENERATION ARCHITECTURE ===
    # The system works in a loop:
    # 1. Generate KEYFRAME (full SD diffusion, ~2.1s)
    # 2. Create N INTERPOLATION FRAMES between keyframes (VAE latent lerp)
    # 3. Display all frames at target FPS
    # 4. Repeat with next keyframe
    
    # Number of interpolated frames between each keyframe
    # More frames = smoother animation but longer wait between keyframes
    # Example: 10 frames @ 10fps = 1 second of smooth playback per keyframe
    interpolation_frames: 10
    
    # Target playback framerate (fps) for interpolated frames
    # This controls how fast interpolation frames are displayed
    # TESTED PERFORMANCE:
    # - Full res (512x256): ~4 FPS max
    # - Half res (256x128): ~15 FPS max
    # Set this based on your interpolation_resolution_divisor
    target_interpolation_fps: 4
    
    # Keyframe generation strength (0.0-1.0)
    # Higher = more variation between keyframes, lower = smoother evolution
    keyframe_denoise: 0.3
    
    # PERFORMANCE OPTIMIZATION: Lower-resolution interpolation
    # Interpolate at lower resolution, then upscale for massive speedup
    # TESTED CONFIGURATIONS (2025-11-09):
    # 1 = full resolution (512x256) - highest quality, ~4 FPS
    # 1.5 = 3/4 resolution (384x192) - ~8 FPS
    # 2 = half resolution (256x128) - ~15 FPS
    interpolation_resolution_divisor: 1
    
    # Upscaling method for lower-res interpolation
    # "bilinear" - Fast, good quality (RECOMMENDED)
    # "bicubic" - Slightly better quality, slightly slower
    # "nearest" - Fastest, pixelated (not recommended)
    interpolation_upscale_method: "bilinear"
    
    # Downsampling method before VAE encoding (for lower-res interpolation)
    # "bilinear" - Fast, good quality (RECOMMENDED)
    # "bicubic" - Middle ground, slight quality improvement
    # "lanczos" - Best quality, slightly slower (~10ms overhead)
    interpolation_downsample_method: "bicubic"
  
  # img2img parameters (for feedback loop mode)
  img2img:
    denoise: 0.35               # Lower = slower drift, higher = more variation
    # 0.3 = very slow evolution (preserves structure)
    # 0.4 = balanced (recommended)
    # 0.5 = faster changes
    # 0.6+ = rapid mutation (might break aesthetic)
  
  # Cache system
  cache:
    max_size: 50                    # Number of images to cache (LRU eviction)
    injection_probability: 0.15     # 15% chance to inject cached image
    similarity_threshold: 0.8       # CLIP similarity threshold (0.7-0.8 recommended)
    # 0.9-1.0 = nearly identical
    # 0.8-0.9 = very similar
    # 0.7-0.8 = similar aesthetic (good for injection)
    # 0.6-0.7 = related style
    # < 0.6   = different aesthetic

display:
  # === BUFFERED DISPLAY SYSTEM ===
  # New architecture: Fill buffer with frames before starting playback
  # This ensures smooth, uninterrupted visual experience
  
  # Buffer target in seconds (30s = "crumple zone" for smooth playback)
  # System will generate this many seconds worth of frames before displaying
  buffer_target_seconds: 30.0
  
  # Minimum buffer before starting playback (can be lower than target for faster startup)
  min_buffer_seconds: 10.0
  
  # NOTE: Display FPS is controlled by hybrid.target_interpolation_fps
  
  # Output management
  max_output_frames: 100          # Keep only last N frames in output dir (prevents unbounded growth)
  
prompts:
  # Base theme templates (rotate through these)
  base_themes:
    - "black, white, ethereal digital angel, dissolving into particles, flowing white lines, technical wireframe overlay, monochrome, sparse color accents, architectural diagrams, high contrast, abstract geometry"
    - "abstract geometry, technical wireframe, architectural diagrams, flowing lines, blueprint aesthetic, monochrome with data corruption, cyberpunk overlay, grid patterns, high contrast"
    - "cyberpunk angel, glitch art aesthetic, digital corruption, technical overlay, particle dissolution, monochrome with red and cyan accents, wireframe structure, abstract form, high contrast"
    - "black, white, ethereal figure in data stream, technical readouts, flowing particles, architectural wireframe, monochrome with blue highlights, digital dissolution, abstract geometry, high contrast"
  
  # Prompt modifiers (optional enhancements)
  modifiers:
    enabled: true
    time_based: true              # Inject time-of-day variations
    system_based: false           # Future: CPU load affects prompt
  
  # Rotation strategy - KEYFRAME based (not interpolation frames!)
  # Prompts rotate when generating new keyframes, not during interpolation
  rotation_interval: 20           # Number of KEYFRAMES before switching base theme
                                  # Example: 20 keyframes = 20 theme cycles before rotation
  
  # Negative prompt (always used)
  negative: "colors, red, blue, green, yellow, orange, purple, pink, brown, black, white, gray, silver, gold, platinum, rainbow, multicolor, psychedelic, trippy, fractal, glitch, noise, blur, low quality, text, watermark, signature, jpeg artifacts, low contrast, muddy colors, brown tones, warm colors"

# Game detection (auto-pause generation)
game_detection:
  enabled: true
  method: "process"               # "process", "gpu_load", or "fullscreen"
  check_interval: 5.0             # Seconds between checks
  
  # Known game executables (add your games here)
  known_games:
    - "eldenring.exe"
    - "cyberpunk2077.exe"
    - "game.exe"
  
  gpu_threshold: 80               # GPU load % to trigger pause (if using gpu_load method)
  
performance:
  max_queue_size: 60              # Max frames in generation queue
  generation_timeout: 120          # Seconds before considering generation stuck (increased for Maxwell GPUs)
  enable_torch_compile: false     # PyTorch 2.0 optimization (experimental)
  async_file_operations: true     # Non-blocking file writes

# Aesthetic validation (quality control)
aesthetic:
  clip_model: "openai/clip-vit-base-patch32"
  validation_enabled: false       # Future: reject images that drift too far
  similarity_warning_threshold: 0.5  # Warn if drifting from seed aesthetic

# Daemon service (for Rainmeter auto-launch and process management)
daemon:
  enabled: true                   # Enable daemon mode (vs manual launch)
  
  # ComfyUI Backend Configuration
  # IMPORTANT: Customize these paths for your setup!
  comfyui:
    # Path to ComfyUI startup script (relative to project root or absolute)
    # The .bat file handles ComfyUI's own virtual environment
    # Windows: Use .bat file (recommended)
    # Linux/Mac: Use .sh file or python command
    startup_script: "diffusion/ComfyUI/run_nvidia_gpu_gpu1_fast.bat"
    
    # Alternative examples:
    # startup_script: "diffusion/ComfyUI/run_nvidia_gpu.bat"
    # startup_script: "uv run diffusion/ComfyUI/main.py --listen 127.0.0.1 --port 8188"
    
    # How long to wait for ComfyUI to become responsive (seconds)
    startup_timeout: 300
    
    # Health check: URL to verify ComfyUI is ready
    health_check_url: "http://127.0.0.1:8188/system_stats"
    health_check_interval: 2      # Seconds between checks during startup
  
  # DreamController Configuration
  controller:
    # Python executable for running the controller
    # Options:
    #   "auto" - Use current Python (same as daemon)
    #   ".venv/Scripts/python.exe" - Explicit venv path (Windows)
    #   ".venv/bin/python" - Explicit venv path (Linux/Mac)
    #   "C:/path/to/python.exe" - Absolute path
    python_executable: ".venv/Scripts/python.exe"
    
    # Script to run
    main_script: "backend/main.py"
    
  # Process Management
  auto_restart:
    comfyui: true                 # Auto-restart ComfyUI if it crashes
    controller: true              # Auto-restart dream_gen loop if it crashes
    max_restarts: 5               # Max restarts before giving up (per hour)
    restart_delay: 10             # Seconds to wait before restart attempt
    
  # Control Interface
  control_file: "output/daemon_control.txt"   # File for pause/resume/shutdown commands
  control_check_interval: 2       # Seconds between checking control file
  
  # Status & Monitoring
  pid_file: "output/daemon.pid"   # PID file for daemon process tracking
  status_update_interval: 5       # Seconds between daemon status updates
  
  # Graceful Shutdown
  shutdown:
    comfyui_grace_period: 30      # Seconds to wait for ComfyUI clean exit
    controller_grace_period: 10   # Seconds to wait for controller clean exit
    force_kill_after_timeout: true # Force kill if grace period expires
    
  # Logging
  log_file: "logs/daemon.log"     # Daemon-specific log file
  log_level: "INFO"               # DEBUG, INFO, WARNING, ERROR

